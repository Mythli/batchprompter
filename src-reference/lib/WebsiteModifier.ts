import OpenAI from 'openai';
import { diff_match_patch } from 'diff-match-patch';
import { PuppeteerPageHelper, Resolution, ScreenshotData } from "./PupeteerPageHelper.js";
import {AskGptFunction} from "./createCachedGptAsk.js";
import { PuppeteerHelper } from './PuppeteerHelper.js';
import { compressHtml } from './compressHtml.js';
import { EventTracker } from './EventTracker.js';
import { BuildSingleFilePageGenerator } from '../getConfig.js';

export interface WebsiteModifierInput {
    url: string;
    instruction: string;
    maxIterations?: number;
    stopThreshold?: number;
    failureThreshold?: number;
}

export interface VerificationResult {
    score: number;
    feedback: string;
}

export interface ModificationIterationResult {
    iteration: number;
    /** The Javascript code generated by the developer agent. */
    generatedCode: string;
    /** The HTML after executing the code. Null if the execution failed. */
    modifiedHtml: string | null;
    /** Screenshots of the modified HTML. */
    screenshots: ScreenshotData[];
    /** The result from the verification agent. */
    verification: VerificationResult;
    /** A snapshot of the developer agent's conversation for this step. */
    developerConversationSnapshot: OpenAI.Chat.Completions.ChatCompletionMessageParam[];
}

export interface ModificationProcessResult {
    originalHtml: string;
    originalScreenshots: ScreenshotData[];
    isSuccess: boolean;
    iterations: ModificationIterationResult[];
    bestIteration: ModificationIterationResult | null;
}

/**
 * Orchestrates website modification using an iterative "generate code, execute, and verify" loop.
 * This version uses the WebPageScraper's `pageInteraction` feature to safely execute
 * LLM-generated JavaScript within a sandboxed browser environment. This version also maintains
 * conversational context for both the developer and verifier agents.
 */
export class WebsiteModifier {
    private puppeteerHelper: PuppeteerHelper;
    private ask: AskGptFunction;
    private buildSingleFilePageGenerator: BuildSingleFilePageGenerator;
    private eventTracker: EventTracker;
    private readonly resolutions: Resolution[] = [
        {width: 1920, height: 1080}, // Desktop
    ];

    constructor(
        puppeteerHelper: PuppeteerHelper,
        ask: AskGptFunction,
        buildSingleFilePageGenerator: BuildSingleFilePageGenerator,
        eventTracker: EventTracker
    ) {
        this.puppeteerHelper = puppeteerHelper;
        this.ask = ask;
        this.buildSingleFilePageGenerator = buildSingleFilePageGenerator;
        this.eventTracker = eventTracker;
    }

    private async disableJavascriptPageInteraction(page: any) {
        await page.setJavaScriptEnabled(false);
    }

    private parseLlmCodeResponse(rawResponse: string | null): string {
        if (!rawResponse) {
            console.warn('[Modifier] LLM returned a null or empty response for the code.');
            return '';
        }
        const codeMatch = rawResponse.match(/```(javascript|js)?\s*([\s\S]*?)\s*```/);
        if (codeMatch && codeMatch[2]) {
            return codeMatch[2].trim();
        }
        return rawResponse.trim();
    }

    private parseLlmVerificationResponse(rawResponse: string | null): VerificationResult {
         if (!rawResponse) {
            console.warn('[Modifier] LLM returned a null or empty verification response.');
            return { score: 1, feedback: "Error: The verifier LLM returned an empty response." };
        }
        try {
            // The verifier prompt now asks for raw JSON, but we handle both cases for robustness.
            const jsonMatch = rawResponse.match(/```json\s*([\s\S]*?)\s*```/);
            const jsonString = (jsonMatch ? jsonMatch[1] : rawResponse) as string;
            const parsed = JSON.parse(jsonString);

            if (typeof parsed.score === 'number' && typeof parsed.feedback === 'string') {
                 const score = Math.max(1, Math.min(10, parsed.score));
                 return { score, feedback: parsed.feedback };
            }
             throw new Error("Parsed JSON does not match the expected structure ({ score: number, feedback: string }).");
        } catch (error) {
            console.error('[Modifier] Failed to parse verification JSON from LLM:', error);
            console.error('[Modifier] Raw response was:', rawResponse);
            return {
                score: 1,
                feedback: `Technical Error: Could not parse the verifier's response. The raw response was: ${rawResponse}`
            };
        }
    }


    public async modify(input: WebsiteModifierInput): Promise<ModificationProcessResult> {
        const {
            url,
            instruction,
            maxIterations = 3,
            stopThreshold = 8,
            failureThreshold = 3
        } = input;
        console.log(`[Modifier] Starting modification process for URL: ${url}`);
        console.log(`[Modifier] Instruction: "${instruction}"`);
        console.log(`[Modifier] Options: maxIterations=${maxIterations}, stopThreshold=${stopThreshold}, failureThreshold=${failureThreshold}`);
        const allIterationResults: ModificationIterationResult[] = [];

        let originalHtml: string = '';
        let originalScreenshots: ScreenshotData[] = [];

        await this.eventTracker.trackOperation('get_original_page', { url }, async () => {
            const pageHelper = await this.puppeteerHelper.getPageHelper();
            try {
                // await this.disableJavascriptPageInteraction(pageHelper.getPage());
                originalHtml = await pageHelper.navigateToUrlAndGetHtml(url);
                await pageHelper.drawGridOverlay();
                originalScreenshots = await pageHelper.takeScreenshots(this.resolutions);

                console.log('yeah');
            } finally {
                await pageHelper.close();
            }
        });

        const loopLimit = maxIterations === 0 ? 1 : maxIterations;
        const performVerification = maxIterations > 0;

        const developerSystemPrompt = this.buildDeveloperSystemPrompt(instruction);
        const verifierSystemPrompt = this.buildVerifierSystemPrompt(instruction);

        const developerConversation: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
            {role: 'system', content: developerSystemPrompt}
        ];
        const verifierConversation: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
            {role: 'system', content: verifierSystemPrompt}
        ];

        const cumulativeCode: string[] = [];
        let lastAttemptFeedback = `This is the first attempt. Please generate the JavaScript code to apply the change requested in the system prompt.`;
        let lastAttemptScreenshots: ScreenshotData[] | null = originalScreenshots;
        let lastAttemptDiff: string | undefined = undefined;
        let bestIterationResult: ModificationIterationResult | null = null;

        for (let i = 1; i <= loopLimit; i++) {
            console.log(`[Modifier] --- Iteration ${i}/${loopLimit} ---`);
            const developerUserMessage = this.buildDeveloperUserMessage(
                i,
                originalHtml,
                lastAttemptFeedback,
                lastAttemptScreenshots,
                lastAttemptDiff
            );
            developerConversation.push(developerUserMessage);

            const developerConversationSnapshot = [...developerConversation];
            const codeResponse = await this.eventTracker.trackOperation(
                'generate_code',
                { iteration: i },
                () => this.ask({messages: developerConversation})
            );
            developerConversation.push({role: 'assistant', content: codeResponse || ''});
            const generatedCode = this.parseLlmCodeResponse(codeResponse);
            console.log(`[Modifier] Generated code for iteration ${i}.`);

            let modifiedHtml: string | null = null;
            let screenshots: ScreenshotData[] = [];
            let verification: VerificationResult;
            let currentDiff: string | undefined;

            try {
                await this.eventTracker.trackOperation('execute_code_and_screenshot', { iteration: i, url }, async () => {
                    const modificationPage = await this.puppeteerHelper.getPage();
                    try {
                        const pageHelper = new PuppeteerPageHelper(modificationPage, null); // No adblocker
                        await pageHelper.setupPage();

                        await this.disableJavascriptPageInteraction(modificationPage);
                        await pageHelper.navigateToUrlAndGetHtml(url);

                        // Execute modification script
                        if (generatedCode) {
                            await modificationPage.setJavaScriptEnabled(true);
                            await modificationPage.evaluate(generatedCode);
                        }

                        modifiedHtml = await pageHelper.getFinalHtml();
                        if (modifiedHtml) {
                            const dmp = new diff_match_patch();
                            const patches = dmp.patch_make(originalHtml, modifiedHtml);
                            currentDiff = dmp.patch_toText(patches);
                        }
                        await pageHelper.drawGridOverlay();
                        screenshots = await pageHelper.takeScreenshots(this.resolutions);
                        cumulativeCode.push(generatedCode);
                    } finally {
                        await modificationPage.close();
                    }
                });
            } catch (e) {
                console.error('[Modifier] Failed to execute generated code via scraper:', e);
                lastAttemptFeedback = `Your last generated code snippet failed to execute and has been discarded because it produced this error: "${e instanceof Error ? e.message : String(e)}". Please review our conversation history and generate a new, valid script to accomplish the original goal. Do not repeat the same mistake.`;
                lastAttemptScreenshots = null;
                lastAttemptDiff = undefined;
                developerConversation.pop();
                allIterationResults.push({
                    iteration: i,
                    generatedCode,
                    modifiedHtml: null,
                    screenshots: [],
                    verification: {score: 1, feedback: `Failed to execute code: ${e instanceof Error ? e.message : String(e)}`},
                    developerConversationSnapshot: developerConversationSnapshot
                });
                console.log(`[Modifier] Iteration ${i} failed due to code execution error.`);
                continue;
            }

            if (currentDiff === '') {
                console.log(`[Modifier] Iteration ${i}: Code produced no HTML changes. Skipping verification.`);
                verification = {
                    score: 1,
                    feedback: "The submitted code ran without errors, but it did not cause any changes to the page's HTML. The page remains identical to its original state. Please write new code that modifies the DOM as requested."
                };
            } else if (!performVerification) {
                console.log(`[Modifier] Iteration ${i}: Verification skipped (maxIterations=0).`);
                verification = {
                    score: 10, // We assume success as verification is skipped.
                    feedback: "Modification executed. Verification was skipped as per maxIterations=0."
                };
            } else {
                const verifierUserMessage = this.buildVerifierUserMessage(i, originalScreenshots, screenshots, currentDiff);
                verifierConversation.push(verifierUserMessage);

                const verificationResponse = await this.eventTracker.trackOperation(
                    'verify_changes',
                    { iteration: i },
                    () => this.ask({messages: verifierConversation})
                );
                verifierConversation.push({ role: 'assistant', content: verificationResponse || '' });
                verification = this.parseLlmVerificationResponse(verificationResponse);
                console.log(`[Modifier] Iteration ${i} verification result - Score: ${verification.score}, Feedback: "${verification.feedback}"`);
            }


            const currentIterationResult = {
                iteration: i,
                generatedCode,
                modifiedHtml,
                screenshots,
                verification,
                developerConversationSnapshot: developerConversationSnapshot
            };
            allIterationResults.push(currentIterationResult);

            if (!bestIterationResult || currentIterationResult.verification.score > bestIterationResult.verification.score) {
                console.log(`[Modifier] New best score: ${currentIterationResult.verification.score} (previous best: ${bestIterationResult?.verification.score || 'N/A'})`);
                bestIterationResult = currentIterationResult;
            }

            if (verification.score >= stopThreshold) {
                console.log(`[Modifier] Iteration ${i}: Score ${verification.score} meets stop threshold ${stopThreshold}. Stopping.`);
                break;
            }

            lastAttemptFeedback = `Your last attempt was not good enough (Score: ${verification.score}/10). A QA specialist provided this feedback: "${verification.feedback}". I have provided the screenshots from your last attempt. Please review your code, the feedback, and the screenshots to generate a *new script* that corrects the issue.`;
            lastAttemptScreenshots = screenshots;
            lastAttemptDiff = currentDiff;


            if (i === loopLimit && performVerification) {
                 console.warn(`[Modifier] Max iterations reached without reaching stopThreshold ${stopThreshold}. Final score: ${verification.score}.`);
            }
        }

        let isSuccess = false;
        if (bestIterationResult && bestIterationResult.verification.score >= failureThreshold) {
            isSuccess = true;
        }

        console.log(`[Modifier] Modification process finished. Success: ${isSuccess}. Best score: ${bestIterationResult?.verification.score || 'N/A'}`);

        return {
            originalHtml,
            originalScreenshots,
            isSuccess,
            iterations: allIterationResults,
            bestIteration: bestIterationResult,
        };
    }

    private buildDeveloperUserMessage(
        iteration: number,
        html: string,
        feedback: string,
        screenshots: ScreenshotData[] | null,
        diff?: string
    ): OpenAI.Chat.Completions.ChatCompletionMessageParam {
        const content: OpenAI.Chat.Completions.ChatCompletionContentPart[] = [{ type: 'text', text: feedback }];

        if (iteration === 1) {
            const compressedHtml = compressHtml(html);
            content.push({
                type: 'text',
                text: `\n\nHere is the initial HTML of the page for your reference.\n\`\`\`html\n${compressedHtml}\n\`\`\``
            });
            if (screenshots && screenshots.length > 0) {
                 content.push({
                    type: 'text',
                    text: `\n\nFor additional context, here are screenshots of the page's initial state. Use these and the HTML to guide your first attempt.`
                });
                content.push(...screenshots.map(s => ({
                    type: 'image_url' as const,
                    image_url: {url: s.screenshotBase64, detail: 'high' as const}
                })));
            }
        } else if (screenshots && screenshots.length > 0) {
            content.push({
                type: 'text',
                text: `\n\nFor your reference, here are the screenshots that resulted from your last attempt:`
            });
            content.push(...screenshots.map(s => ({
                type: 'image_url' as const,
                image_url: {url: s.screenshotBase64, detail: 'high' as const}
            })));
            if (diff) {
                content.push({
                    type: 'text',
                    text: `\n\nHere is a diff showing the changes your last script made to the HTML:\n\`\`\`diff\n${diff}\n\`\`\``
                });
            }
        }

        return {
            role: 'user',
            content,
        };
    }

    private buildDeveloperSystemPrompt(instruction: string): string {
            return `**INSTRUCTION**
${instruction}

**HOW IT WORKS:**
- You will work in an iterative loop.
- **On your first attempt, I will provide the full HTML of the page and screenshots of its initial state.** You will not see them again, so pay attention.
- You will provide a JavaScript snippet to make a change.
- I will execute your script. **Each new script you provide is appended to the list of scripts to run. All your previous, successful scripts will be re-executed from a fresh page load before your new script runs.**
- A QA agent will then verify if the change was successful by looking at screenshots.
- **If your attempt is not satisfactory, I will provide the QA feedback, screenshots of the result, and a diff of the HTML changes.** You must then provide a *new* JavaScript snippet to correct the state.
- This process repeats until the task is complete.

**SCREENSHOTS:**
- All screenshots include a red grid overlay with pixel markings.
- Use this grid to precisely assess alignment, spacing, and positioning of elements.

**RULES:**
- Your response MUST be ONLY the JavaScript code.
- **Wrap your code in a single \`\`\`javascript ... \`\`\` markdown block.**
- Do not add explanations. Just the code.
- Use standard browser APIs (e.g., 'document.querySelector'). Do not use jQuery.
- In every single interation you start fresh with the initial HTML

**EXAMPLE:**
Instruction: "Change the h1 to 'Welcome!' and make it blue."

*My first message to you will contain the HTML, initial screenshots, and the instruction.*

*Your 1st response (wrong):*
\`\`\`javascript
document.querySelector('h1').textContent = 'Welcome!';
\`\`\`

*My next message might be: "Your last attempt was not good enough (Score: 6/10). A QA specialist provided this feedback: 'The text is correct but you forgot to make it blue.' and I will show you a screenshot of the page with the H1 text changed.*

*Your 2nd response you must do everything in one script since you are always working with the initial HTML:*
\`\`\`javascript
document.querySelector('h1').textContent = 'Welcome!';
document.querySelector('h1').style.color = 'blue';
\`\`\`
`;
    }

    private buildVerifierSystemPrompt(instruction: string): string {
        return `You are a meticulous QA specialist. Your task is to evaluate how well a webpage modification instruction has been carried out by looking at 'BEFORE' and 'AFTER' screenshots.

**THE GOAL TO VERIFY:**
${instruction}

**YOUR TASK:**
1.  I will provide "BEFORE" screenshots (the original page) and "AFTER" screenshots (the modified page).
2.  Carefully compare the "AFTER" screenshots to the "BEFORE" screenshots and the "THE GOAL TO VERIFY" instruction.
3.  This is a multi-step process. If this is not the first attempt, review the previous feedback you gave and check if the specific issues have been resolved in the new "AFTER" images. I may also provide a diff of the HTML changes for more technical context.
4.  Assign a score from 1 to 10 based on how well the goal has been met.
5.  Provide concise, actionable feedback for the developer.

**NOTE ON SCREENSHOTS:**
- All screenshots include a red grid overlay with pixel markings.
- Use this grid to precisely assess alignment, spacing, and positioning.

**SCORING GUIDE:**
- **1-3 (Poor/Broken):** The change is completely wrong, or the page is visually broken/unusable. The instruction was misunderstood or ignored.
- **4-6 (Needs Major Work):** A poor attempt. The modification is partially correct but has significant errors or omissions. For example, the text was changed, but the color was not, or the wrong element was targeted.
- **7-8 (Good, but not perfect):** A good attempt. The main goal is achieved, but there are minor issues. For example, the color is slightly off, the alignment is wrong, or there's a small mistake in the text.
- **9-10 (Excellent/Perfect):** An excellent, near-perfect execution of the instruction. The change is exactly as requested.

**RESPONSE FORMAT:**
- **You MUST respond with ONLY a single, raw JSON object.**
- Your entire response must be the JSON object and nothing else.
- **DO NOT wrap the JSON in markdown like \`\`\`json ... \`\`\`.**

**JSON STRUCTURE:**
{
  "score": number, // A single integer from 1 to 10 based on your scoring guide.
  "feedback": "A concise explanation for the developer that justifies your score. If the score is below 9, explain clearly what is still wrong or missing by comparing the 'AFTER' state to the original state and the desired goal."
}`;
    }

    private buildVerifierUserMessage(
        iteration: number,
        originalScreenshots: ScreenshotData[],
        modifiedScreenshots: ScreenshotData[],
        diff?: string
    ): OpenAI.Chat.Completions.ChatCompletionMessageParam {
        const parts: OpenAI.Chat.Completions.ChatCompletionContentPart[] = [];

        if (iteration === 1) {
            parts.push({
                type: 'text',
                text: `Please review if the webpage shown in the 'AFTER' images below meets the goal defined in your system prompt.

---
**BEFORE (Original Page)**
This is the page *before* any changes were made. Remember this state.
---`,
            });
            parts.push(...originalScreenshots.map(s => ({
                type: 'image_url' as const,
                image_url: {url: s.screenshotBase64, detail: 'high' as const}
            })));
        } else {
             parts.push({
                type: 'text',
                text: `The developer has made another attempt.`
             });
        }

        parts.push({
            type: 'text',
            text: `---
**AFTER (Modified Page - Attempt #${iteration})**
This is the page *after* the developer's latest code was executed.
---`,
        });
        parts.push(...modifiedScreenshots.map(s => ({
            type: 'image_url' as const,
            image_url: {url: s.screenshotBase64, detail: 'high' as const}
        })));

        if (diff) {
            parts.push({
                type: 'text',
                text: `\n\nFor additional context, here is a diff of the HTML changes that were made:\n\`\`\`diff\n${diff}\n\`\`\``
            });
        }

        return {
            role: 'user',
            content: parts,
        };
    }
}
