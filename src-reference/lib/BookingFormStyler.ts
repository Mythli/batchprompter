import OpenAI from 'openai';
import { AskGptFunction } from "./createCachedGptAsk.js";
import { PuppeteerHelper } from './PuppeteerHelper.js';
import { PuppeteerPageHelper, Resolution, ScreenshotData } from './PupeteerPageHelper.js';
import {Page} from "puppeteer";
import { InteractiveElementScreenshoter, InteractiveElementsResult, ElementScreenshot } from './InteractiveElementScreenshoter.js';
import { EventTracker } from './EventTracker.js';

// Input for the styling process
export interface BookingFormStylerInput {
    bookingFormUrl: string;
    bookingFormIntegratedUrl: string;
    referenceUrls: string[];
    maxIterations?: number;
    stopThreshold?: number;
    failureThreshold?: number;
}

// Result of the verifier agent's check
export interface VerificationResult {
    score: number;
    feedback: string;
}

// Result of a single styling iteration
export interface StylingIterationResult {
    iteration: number;
    /** The CSS code generated by the styler agent. */
    generatedCss: string;
    /** Screenshots of the styled booking form. */
    screenshots: ScreenshotData[];
    /** Screenshots of the interactive elements on the styled booking form. */
    interactionScreenshots: InteractiveElementsResult;
    /** The result from the verification agent. */
    verification: VerificationResult;
    /** A snapshot of the styler agent's conversation for this step. */
    stylerConversationSnapshot: OpenAI.Chat.Completions.ChatCompletionMessageParam[];
}

export interface ReferenceWebsiteData {
    url: string;
    fullPageScreenshots: ScreenshotData[];
    interactionScreenshots: InteractiveElementsResult;
}

// The final result of the entire styling process
export interface StylingProcessResult {
    originalBookingForm: {
        html: string;
        css: string;
        screenshots: ScreenshotData[];
        interactionScreenshots: InteractiveElementsResult;
    };
    referenceWebsiteData: ReferenceWebsiteData[];
    /** The final, cumulative CSS generated and applied. */
    finalCss: string | null;
    isSuccess: boolean;
    iterations: StylingIterationResult[];
}

export const sleep = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const rootElementSelector = '[data-ws-type="WSROOT"]';

/**
 * Orchestrates styling a booking form based on reference websites using an iterative
 * "generate style, execute, and verify" loop. It uses two conversational LLM agents:
 * a "Styler" to generate CSS, and a "Verifier" to check the results.
 */
export class BookingFormStyler {
    private puppeteerHelper: PuppeteerHelper;
    private ask: AskGptFunction;
    private interactiveElementScreenshoter: InteractiveElementScreenshoter;
    private eventTracker: EventTracker;
    private readonly resolutions: Resolution[] = [
        {width: 1920, height: 1080}, // Desktop
        {width: 375, height: 812},  // Mobile
    ];

    constructor(puppeteerHelper: PuppeteerHelper, ask: AskGptFunction, interactiveElementScreenshoter: InteractiveElementScreenshoter, eventTracker: EventTracker) {
        this.puppeteerHelper = puppeteerHelper;
        this.ask = ask;
        this.interactiveElementScreenshoter = interactiveElementScreenshoter;
        this.eventTracker = eventTracker;
    }

    private parseLlmCssResponse(rawResponse: string | null): string {
        if (!rawResponse) {
            return '';
        }
        const codeMatch = rawResponse.match(/```(css)?\s*([\s\S]*?)\s*```/);
        if (codeMatch && codeMatch[2]) {
            return codeMatch[2].trim();
        }
        return rawResponse.trim();
    }

    private parseLlmVerificationResponse(rawResponse: string | null): VerificationResult {
         if (!rawResponse) {
            return { score: 1, feedback: "Error: The verifier LLM returned an empty response." };
        }
        try {
            // The verifier prompt now asks for raw JSON, but we handle both cases for robustness.
            const jsonMatch = rawResponse.match(/```json\s*([\s\S]*?)\s*```/);
            const jsonString = (jsonMatch ? jsonMatch[1] : rawResponse) as string;
            const parsed = JSON.parse(jsonString);

            if (typeof parsed.score === 'number' && typeof parsed.feedback === 'string') {
                 const score = Math.max(1, Math.min(10, parsed.score));
                 return { score, feedback: parsed.feedback };
            }
             throw new Error("Parsed JSON does not match the expected structure ({ score: number, feedback: string }).");
        } catch (error) {
            console.error('[Styler] Failed to parse verification JSON from LLM:', error);
            console.error('[Styler] Raw response was:', rawResponse);
            return {
                score: 1,
                feedback: `Technical Error: Could not parse the verifier's response. The raw response was: ${rawResponse}`
            };
        }
    }

    private async _getOriginalBookingFormAssets(bookingFormUrl: string, pageHelper: PuppeteerPageHelper): Promise<{ html: string; css: string; }> {
        const cacheKey = `booking-form-assets:${bookingFormUrl}`;

        try {
            const assets = await pageHelper.navigateAndCache(
                bookingFormUrl,
                async (helper) => {
                    await helper.getPage().waitForSelector(rootElementSelector, { timeout: 5000 });
                    const html = await helper.getPage().$eval(rootElementSelector, element => element.innerHTML);
                    const css = await helper.getCss();
                    return { html, css };
                },
                {
                    cacheKey,
                    beforeNavigate: async (helper) => {
                        await helper.startCssExtraction();
                    }
                }
            );
            return assets;
        } catch (e) {
            console.error(`[Styler] Failed to get booking form assets from ${bookingFormUrl}:`, e);
            throw e; // Re-throw to fail the whole process
        }
    }

    private async _getIntegratedBookingFormAssets(url: string): Promise<{ screenshots: ScreenshotData[], interactionScreenshots: InteractiveElementsResult }> {
        let pageHelper: PuppeteerPageHelper | null = null;
        try {
            pageHelper = await this.puppeteerHelper.getPageHelper();
            const assets = await pageHelper.navigateAndCache(
                url,
                async (helper) => {
                    await helper.getPage().waitForSelector(rootElementSelector, { timeout: 5000 });
                    const screenshots = await helper.takeScreenshots(this.resolutions);

                    const interactionScreenshots = await this.interactiveElementScreenshoter.screenshot(helper, {
                        createCompositeImage: true,
                        scopeSelector: rootElementSelector
                    });

                    return { screenshots, interactionScreenshots };
                },
                { cacheKey: `integrated-assets:${url}` }
            );
            return assets;
        } catch (e) {
            console.error(`[Styler] Failed to get assets from ${url}:`, e);
            throw e;
        } finally {
            if (pageHelper) await pageHelper.close();
        }
    }

    private async _getReferenceWebsiteData(urls: string[]): Promise<ReferenceWebsiteData[]> {
        const dataPromises = urls.map(async (url) => {
            let pageHelper: PuppeteerPageHelper | null = null;
            try {
                pageHelper = await this.puppeteerHelper.getPageHelper();
                const data = await pageHelper.navigateAndCache(
                    url,
                    async (helper) => {
                        const fullPageScreenshots = await helper.takeScreenshots(this.resolutions);

                        const interactionScreenshots = await this.interactiveElementScreenshoter.screenshot(helper, {
                            maxButtons: 2,
                            maxInputs: 2,
                            maxLinks: 1,
                            createCompositeImage: true
                        });

                        return { fullPageScreenshots, interactionScreenshots };
                    },
                    { cacheKey: `reference-assets:${url}` }
                );
                return { url, ...data };
            } catch (e) {
                return null; // Return null on failure to avoid breaking Promise.all
            } finally {
                if (pageHelper) await pageHelper.close();
            }
        });

        const results = await Promise.all(dataPromises);
        const referenceData = results.filter((r): r is ReferenceWebsiteData => r !== null);
        return referenceData;
    }

    protected async navigateToBookingForm(pageHelper: PuppeteerPageHelper, bookingFormUrl: string) {
        const result = await pageHelper.navigateToUrl(bookingFormUrl);
        await pageHelper.getPage().waitForSelector(rootElementSelector, { timeout: 5000 });
        return result;
    }

    private async _initializeStylingProcess(
        bookingFormUrl: string,
        bookingFormIntegratedUrl: string,
        referenceUrls: string[]
    ): Promise<{
        referenceWebsiteData: ReferenceWebsiteData[];
        originalBookingForm: { html: string; css: string; screenshots: ScreenshotData[]; interactionScreenshots: InteractiveElementsResult };
    }> {
        // Start fetching all data in parallel.
        const referenceDataPromise = this._getReferenceWebsiteData(referenceUrls);

        const bookingFormAssetsPromise = (async () => {
            let pageHelper: PuppeteerPageHelper | null = null;
            try {
                pageHelper = await this.puppeteerHelper.getPageHelper();
                return await this._getOriginalBookingFormAssets(bookingFormUrl, pageHelper);
            } finally {
                if (pageHelper) await pageHelper.close();
            }
        })();

        // Fetch the integrated screenshots using the new cached method.
        const initialAssetsPromise = this._getIntegratedBookingFormAssets(bookingFormIntegratedUrl);

        // Wait for all parallel data gathering to complete.
        const [
            referenceWebsiteData,
            bookingFormAssets,
            initialBookingFormAssets
        ] = await Promise.all([
            referenceDataPromise,
            bookingFormAssetsPromise,
            initialAssetsPromise
        ]);

        const originalBookingForm = {
            ...bookingFormAssets,
            screenshots: initialBookingFormAssets.screenshots,
            interactionScreenshots: initialBookingFormAssets.interactionScreenshots
        };

        return {
            referenceWebsiteData,
            originalBookingForm,
        };
    }

    public async style(input: BookingFormStylerInput): Promise<StylingProcessResult> {
        const {
            bookingFormUrl,
            bookingFormIntegratedUrl,
            referenceUrls,
            maxIterations = 3,
            stopThreshold = 8,
            failureThreshold = 3
        } = input;
        const allIterationResults: StylingIterationResult[] = [];

        let pageHelperForStyling: PuppeteerPageHelper | null = null;
        try {
            const {
                referenceWebsiteData,
                originalBookingForm,
            } = await this.eventTracker.trackOperation(
                'initialize_styling_process',
                { bookingFormUrl, bookingFormIntegratedUrl, referenceUrls },
                () => this._initializeStylingProcess(bookingFormUrl, bookingFormIntegratedUrl, referenceUrls)
            );

            // Create a new page for the styling process.
            pageHelperForStyling = await this.puppeteerHelper.getPageHelper();
            // Navigate to the page where styles will be injected.
            await this.navigateToBookingForm(pageHelperForStyling, bookingFormIntegratedUrl);

            const stylerSystemPrompt = this.buildStylerSystemPrompt();
            const verifierSystemPrompt = this.buildVerifierSystemPrompt();

            const stylerConversation: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
                {role: 'system', content: stylerSystemPrompt}
            ];
            const verifierConversation: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
                {role: 'system', content: verifierSystemPrompt}
            ];

            let lastAttemptFeedback = `This is the first attempt. Please generate the CSS code to style the booking form to match the provided reference screenshots.`;
            let lastAttemptScreenshots: ScreenshotData[] | null = originalBookingForm.screenshots;
            let lastAttemptInteractionScreenshots: InteractiveElementsResult | null = originalBookingForm.interactionScreenshots;

            let bestIterationResult: StylingIterationResult | null = null;

            const loopCount = maxIterations > 0 ? maxIterations : 1;
            const performVerification = maxIterations > 0;

            for (let i = 1; i <= loopCount; i++) {
                const stylerUserMessage = this.buildStylerUserMessage(
                    i,
                    originalBookingForm,
                    referenceWebsiteData,
                    lastAttemptFeedback,
                    lastAttemptScreenshots,
                    lastAttemptInteractionScreenshots
                );
                stylerConversation.push(stylerUserMessage);

                const stylerConversationSnapshot = [...stylerConversation];
                const cssResponse = await this.eventTracker.trackOperation(
                    'generate_css',
                    { iteration: i },
                    () => this.ask({messages: stylerConversation})
                );
                stylerConversation.push({role: 'assistant', content: cssResponse || ''});
                const generatedCss = this.parseLlmCssResponse(cssResponse);

                let screenshots: ScreenshotData[] = [];
                let interactionScreenshots: InteractiveElementsResult = { screenshots: [] };
                let verification: VerificationResult;

                try {
                    await this.eventTracker.trackOperation('apply_css_and_screenshot', { iteration: i }, async () => {
                        if (!generatedCss) {
                           throw new Error('No CSS provided.')
                        }

                        const styleTagId = 'ai-generated-styles';
                        await pageHelperForStyling!.getPage().evaluate(({css, id}) => {
                            let styleTag = document.getElementById(id) as HTMLStyleElement | null;
                            if (!styleTag) {
                                styleTag = document.createElement('style');
                                styleTag.id = id;
                                document.head.appendChild(styleTag);
                            }
                            styleTag.innerHTML = css;
                        }, {css: generatedCss, id: styleTagId});

                        await sleep(50); // Give it a moment for styles to apply.

                        screenshots = await pageHelperForStyling!.takeScreenshots(this.resolutions);

                        interactionScreenshots = await this.interactiveElementScreenshoter.screenshot(pageHelperForStyling!, {
                            maxButtons: 2,
                            maxInputs: 2,
                            maxLinks: 1,
                            createCompositeImage: true,
                            scopeSelector: rootElementSelector
                        });
                    });

                } catch (e) {
                    console.error('[Styler] Failed to inject generated CSS:', e);
                    lastAttemptFeedback = `Your last generated CSS snippet failed to be applied because it produced this error: "${e instanceof Error ? e.message : String(e)}". Please review our conversation history and generate a new, valid CSS snippet to accomplish the original goal. Do not repeat the same mistake.`;
                    lastAttemptScreenshots = null;
                    lastAttemptInteractionScreenshots = null;
                    allIterationResults.push({
                        iteration: i,
                        generatedCss,
                        screenshots: [],
                        interactionScreenshots: { screenshots: [] },
                        verification: {score: 1, feedback: `Failed to apply CSS: ${e instanceof Error ? e.message : String(e)}`},
                        stylerConversationSnapshot
                    });
                    continue;
                }

                if (performVerification) {
                    const referenceFullPageScreenshots = referenceWebsiteData.flatMap(d => d.fullPageScreenshots);
                    const verifierUserMessage = this.buildVerifierUserMessage(i, referenceFullPageScreenshots, originalBookingForm.screenshots, screenshots);
                    verifierConversation.push(verifierUserMessage);

                    const verificationResponse = await this.eventTracker.trackOperation(
                        'verify_changes',
                        { iteration: i },
                        () => this.ask({messages: verifierConversation})
                    );
                    verifierConversation.push({ role: 'assistant', content: verificationResponse || '' });
                    verification = this.parseLlmVerificationResponse(verificationResponse);
                } else {
                    // This is the maxIterations === 0 case.
                    verification = { score: 10, feedback: 'Verification skipped as per configuration (maxIterations: 0).' };
                }


                const currentIterationResult = {
                    iteration: i,
                    generatedCss,
                    screenshots,
                    interactionScreenshots,
                    verification,
                    stylerConversationSnapshot
                };
                allIterationResults.push(currentIterationResult);

                if (!bestIterationResult || currentIterationResult.verification.score > bestIterationResult.verification.score) {
                    bestIterationResult = currentIterationResult;
                }

                if (verification.score >= stopThreshold) {
                    break;
                }

                lastAttemptFeedback = `Your last attempt was not good enough (Score: ${verification.score}/10). A QA specialist provided this feedback: "${verification.feedback}". Please review your CSS, the feedback, and the screenshots to generate a *new CSS snippet* that incorporates a fix for these issues.`;
                lastAttemptScreenshots = screenshots;
                lastAttemptInteractionScreenshots = interactionScreenshots;

            }

            let finalCss: string | null = null;
            let isSuccess = false;

            if (bestIterationResult) {
                finalCss = bestIterationResult.generatedCss;
                // Success is defined as the best-scoring attempt meeting the failure threshold.
                if (bestIterationResult.verification.score >= failureThreshold) {
                    isSuccess = true;
                }
            }

            return {
                originalBookingForm,
                referenceWebsiteData,
                finalCss,
                isSuccess,
                iterations: allIterationResults
            };
        } finally {
            if (pageHelperForStyling) await pageHelperForStyling.close();
        }
    }

    private formatElementStylesForPrompt(screenshots: ElementScreenshot[]): string {
        if (!screenshots || screenshots.length === 0) {
            return "No element styles available.";
        }

        const groupedByElement = screenshots.reduce((acc, shot) => {
            const key = `${shot.type} #${shot.elementIndex}`;
            if (!acc[key]) {
                acc[key] = [];
            }
            acc[key].push(shot);
            return acc;
        }, {} as Record<string, ElementScreenshot[]>);

        let text = '';
        for (const [key, shots] of Object.entries(groupedByElement)) {
            shots.sort((a, b) => {
                const order = { normal: 1, hover: 2, focus: 3 };
                // @ts-ignore
                const orderA = order[a.state] || 99;
                // @ts-ignore
                const orderB = order[b.state] || 99;
                return orderA - orderB;
            });

            text += `\n\n**${key}**`;
            for (const shot of shots) {
                text += `\n- **State: ${shot.state}**\n\`\`\`css\n${shot.styles}\n\`\`\``;
            }
        }
        return text;
    }

    private buildStylerUserMessage(
        iteration: number,
        originalBookingForm: { html: string; css: string; screenshots: ScreenshotData[]; interactionScreenshots: InteractiveElementsResult },
        referenceWebsiteData: ReferenceWebsiteData[],
        feedback: string,
        lastAttemptScreenshots: ScreenshotData[] | null,
        lastAttemptInteractionScreenshots: InteractiveElementsResult | null
    ): OpenAI.Chat.Completions.ChatCompletionMessageParam {
        const content: OpenAI.Chat.Completions.ChatCompletionContentPart[] = [{ type: 'text', text: feedback }];

        if (iteration === 1) {
            content.push({
                type: 'text',
                text: `\n\n**TASK:** Your goal is to style the "Booking Form" to look like the "Reference Website".

---
**REFERENCE WEBSITE STYLE**
Here are screenshots of the reference website. Emulate its colors, fonts, spacing, and overall aesthetic.
I'm also providing a composite image of key interactive elements (buttons, inputs, links) to show you their normal, hover, and active states, along with their computed CSS styles.
---`
            });

            for (const refData of referenceWebsiteData) {
                content.push({
                    type: 'text',
                    text: `\n\n**Reference from: ${refData.url}**\nFull page view:`
                });
                content.push(...refData.fullPageScreenshots.map(s => ({
                    type: 'image_url' as const,
                    image_url: {url: s.screenshotBase64, detail: 'high' as const}
                })));

                if (refData.interactionScreenshots.compositeImageBase64) {
                    content.push({
                        type: 'text',
                        text: `\nInteractive element states:`
                    });
                    content.push({
                        type: 'image_url',
                        image_url: { url: refData.interactionScreenshots.compositeImageBase64, detail: 'high' }
                    });
                }

                if (refData.interactionScreenshots.screenshots.length > 0) {
                    content.push({
                        type: 'text',
                        text: `\nComputed CSS for reference interactive elements from ${refData.url}:`
                    });
                    const stylesText = this.formatElementStylesForPrompt(refData.interactionScreenshots.screenshots);
                    content.push({
                        type: 'text',
                        text: stylesText
                    });
                }
            }

            content.push({
                type: 'text',
                text: `\n\n---
**BOOKING FORM (Initial State)**
Here is the HTML, CSS, and screenshots of the booking form you need to style.
---
**HTML:**
\`\`\`html
${originalBookingForm.html}
\`\`\`

**CSS:**
\`\`\`css
${originalBookingForm.css}
\`\`\`

**Screenshots:**`
            });
            content.push(...originalBookingForm.screenshots.map(s => ({
                type: 'image_url' as const,
                image_url: {url: s.screenshotBase64, detail: 'high' as const}
            })));

            if (originalBookingForm.interactionScreenshots.compositeImageBase64) {
                content.push({
                    type: 'text',
                    text: `\nInteractive element states for the booking form:`
                });
                content.push({
                    type: 'image_url',
                    image_url: { url: originalBookingForm.interactionScreenshots.compositeImageBase64, detail: 'high' }
                });
            }

            if (originalBookingForm.interactionScreenshots.screenshots.length > 0) {
                content.push({
                    type: 'text',
                    text: `\nComputed CSS for the booking form's interactive elements:`
                });
                const stylesText = this.formatElementStylesForPrompt(originalBookingForm.interactionScreenshots.screenshots);
                content.push({
                    type: 'text',
                    text: stylesText
                });
            }
        } else if (lastAttemptScreenshots && lastAttemptScreenshots.length > 0) {
            content.push({
                type: 'text',
                text: `\n\nFor your reference, here are the screenshots that resulted from your last attempt:`
            });
            content.push(...lastAttemptScreenshots.map(s => ({
                type: 'image_url' as const,
                image_url: {url: s.screenshotBase64, detail: 'high' as const}
            })));

            if (lastAttemptInteractionScreenshots?.compositeImageBase64) {
                content.push({
                    type: 'text',
                    text: `\n\nHere are the interactive elements from your last attempt:`
                });
                content.push({
                    type: 'image_url',
                    image_url: { url: lastAttemptInteractionScreenshots.compositeImageBase64, detail: 'high' }
                });
            }

            if (lastAttemptInteractionScreenshots?.screenshots && lastAttemptInteractionScreenshots.screenshots.length > 0) {
                content.push({
                    type: 'text',
                    text: `\n\nHere are the computed styles for the interactive elements from your last attempt:`
                });
                const stylesText = this.formatElementStylesForPrompt(lastAttemptInteractionScreenshots.screenshots);
                content.push({
                    type: 'text',
                    text: stylesText
                });
            }
        }

        return {
            role: 'user',
            content,
        };
    }

    private buildStylerSystemPrompt(): string {
        // currently the booking form css variabes are broken
        // - **Use CSS Variables:** The booking form's original CSS likely uses CSS variables for theming (e.g., `--primary-color`). Prioritize overriding these variables before writing complex new selectors. It's the most effective way to apply a new theme.


        return `You are an expert front-end developer specializing in writing clean, effective CSS.

**YOUR TASK:**
Your primary goal is to write CSS to style a "Booking Form" so that it seamlessly integrates into a "Reference Website". The form will be embedded directly onto the reference site's page, so it must look like a natural, native component of that site. You will need to match the reference site's colors, fonts, spacing, borders, and the look and feel of interactive elements.

**HOW IT WORKS:**
This is an iterative process.
1.  **Initial Context:** I will start by giving you screenshots and computed styles from a "Reference Website", along with the HTML, CSS, screenshots, and element styles for the "Booking Form" you need to modify.
2.  **Generate CSS:** You will analyze this context and provide a CSS snippet to style the booking form.
3.  **Review:** I will apply your CSS and show the result to a QA agent.
4.  **Iterate:** I will then send you the QA feedback, along with new screenshots and element styles from your last attempt. You will use this to provide a new, improved CSS snippet. This loop continues until the styling is perfect.

**RULES FOR YOUR CSS:**
- **CSS Only:** Your response MUST contain ONLY the CSS code. No explanations, no apologies, just code.
- **Markdown Block:** Wrap your entire CSS code in a single markdown block: \`\`\`css ... \`\`\`.
- **Styling Only:** You must not hide or remove any elements (e.g., using \`display: none\`), nor change any text content (e.g., using the \`content\` property). Your job is to style the existing elements, not to alter the form's structure or content.
- **Scoping:** All your CSS selectors MUST be scoped to elements inside a container with the class \`.websail\` to avoid affecting the parent page.
- **Inherited Styles:** Because the form is embedded, it may inherit global styles from the parent page for elements like \`h1\`, \`h2\`, \`p\`, \`a\`, etc. However, this is not guaranteed. Your CSS should be robust enough to look good whether these styles are inherited or not. You may need to explicitly set base styles for typography and links.
- **Interactive States:** Do not forget to style interactive states like \`:hover\`, \`:focus\`, and \`:active\` for buttons, links, and inputs to match the reference style.
- **Stable Selectors:** Never use unstable, auto-generated class names (e.g., \`sc-grVGCS\`, \`css-123xyz\`). These can change and break your styles. Rely on stable, semantic class names or element selectors (e.g., \`button\`, \`input[type="text"]\`).
- **Focus on Key Elements:** Pay close attention to buttons, input fields, and links. These are critical for a seamless user experience.
- **Use CSS Variables:** The booking form's original CSS likely uses CSS variables for theming (e.g., \`--primary-color\`). Prioritize overriding these variables before writing complex new selectors. It's the most effective way to apply a new theme.
- **Know when to use and when not to use CSS Variables:** Check how the CSS variables are implemented in the original CSS. Sometimes they don't cut it and you need to write actual css.

**EXAMPLE CSS:**
\`\`\`css
.websail {
    --ws-primary-color: #333333;
}

.websail button.submit {
  border-radius: 8px;
  padding: 10px 20px;
}

.websail button.submit:hover {
  background-color: #0065ff;
}
\`\`\``;
    }

    private buildVerifierSystemPrompt(): string {
        return `You are a meticulous QA specialist and design critic. Your task is to evaluate how well a "Booking Form" has been styled to match a "Reference Website".

**THE GOAL: SEAMLESS INTEGRATION**
The "Booking Form" will be embedded directly onto the "Reference Website". The ultimate goal is seamless integration. When you look at the "AFTER" screenshots, the form should feel like it was designed as a native part of the reference site from the very beginning. It should not look like a generic, third-party widget. It must match the reference site's style (colors, fonts, spacing, borders, button styles, input field styles, etc.).

**YOUR TASK:**
1.  I will provide "REFERENCE" screenshots (the target style) and "AFTER" screenshots (the modified form). On the first turn, I will also show you the "BEFORE" state for context.
2.  Carefully compare the "AFTER" screenshots to the "REFERENCE" screenshots. The key question is: **"Does the form in the 'AFTER' shots look like it belongs on the 'REFERENCE' website?"**
3.  This is a multi-step process. If this is not the first attempt, review the previous feedback you gave and check if the specific issues have been resolved in the new "AFTER" images.
4.  Assign a score from 1 to 10 based on how well the integration goal has been met.
5.  Provide concise, actionable feedback for the developer.

**SCORING GUIDE:**
- **1-3 (Poor/Broken):** The style is a complete mismatch, or the form is visually broken/unusable. It clashes horribly and looks like a bug.
- **4-6 (Needs Major Work):** The styling is a poor match. While usable, it's obviously a third-party element that hasn't been properly themed. Key elements like colors, fonts, or button styles are wrong.
- **7-8 (Good, but not perfect):** A good attempt. The general style (colors, fonts) is correct, but there are noticeable inconsistencies in spacing, borders, or interactive states that prevent it from feeling truly native.
- **9-10 (Excellent/Seamless):** An excellent, near-perfect match. The form looks like it was designed for the reference site. It feels completely integrated and professional.

**RESPONSE FORMAT:**
- **You MUST respond with ONLY a single, raw JSON object.**
- Your entire response must be the JSON object and nothing else.
- **DO NOT wrap the JSON in markdown like \`\`\`json ... \`\`\`.**

**JSON STRUCTURE:**
{
  "score": number, // A single integer from 1 to 10 based on your scoring guide.
  "feedback": "A concise explanation for the developer that justifies your score. If the score is below 9, explain clearly what is still wrong or missing. Be specific. Instead of 'the button is wrong,' say 'The button in the AFTER image has sharp corners, but the buttons on the REFERENCE site have a 4px border-radius.'"
}`;
    }

    private buildVerifierUserMessage(
        iteration: number,
        referenceScreenshots: ScreenshotData[],
        originalBookingFormScreenshots: ScreenshotData[],
        modifiedBookingFormScreenshots: ScreenshotData[]
    ): OpenAI.Chat.Completions.ChatCompletionMessageParam {
        const parts: OpenAI.Chat.Completions.ChatCompletionContentPart[] = [];

        parts.push({
            type: 'text',
            text: `Please review if the "AFTER" images of the booking form below match the style of the "REFERENCE" images, as defined in your system prompt.

---
**REFERENCE STYLE**
This is the target style.
---`,
        });
        parts.push(...referenceScreenshots.map(s => ({
            type: 'image_url' as const,
            image_url: {url: s.screenshotBase64, detail: 'high' as const}
        })));

        if (iteration === 1) {
            parts.push({
                type: 'text',
                text: `
---
**BEFORE (Original Booking Form)**
This is the booking form *before* any changes were made.
---`,
            });
            parts.push(...originalBookingFormScreenshots.map(s => ({
                type: 'image_url' as const,
                image_url: {url: s.screenshotBase64, detail: 'high' as const}
            })));
        } else {
             parts.push({
                type: 'text',
                text: `\n\nThe developer has made another attempt. Please review the new "AFTER" images.`
             });
        }

        parts.push({
            type: 'text',
            text: `---
**AFTER (Styled Booking Form - Attempt #${iteration})**
This is the booking form *after* the developer's latest styling code was executed. Does it match the reference style?
---`,
        });
        parts.push(...modifiedBookingFormScreenshots.map(s => ({
            type: 'image_url' as const,
            image_url: {url: s.screenshotBase64, detail: 'high' as const}
        })));

        return {
            role: 'user',
            content: parts,
        };
    }
}
